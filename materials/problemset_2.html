<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mauricio Bucca">

<title>Ejercicios SOL114</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="problemset_2_files/libs/clipboard/clipboard.min.js"></script>
<script src="problemset_2_files/libs/quarto-html/quarto.js"></script>
<script src="problemset_2_files/libs/quarto-html/popper.min.js"></script>
<script src="problemset_2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="problemset_2_files/libs/quarto-html/anchor.min.js"></script>
<link href="problemset_2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="problemset_2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="problemset_2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="problemset_2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="problemset_2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Ejercicios SOL114</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mauricio Bucca </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<ol type="1">
<li>¿En que consiste la Distribución Normal Standard, cómo se obtiene y cuales son sus principales propiedades?</li>
</ol>
<blockquote class="blockquote">
<ul>
<li><p>La <strong>distribución normal estándar</strong> es un caso particular de la distribución normal, caracterizada por tener una media (<span class="math inline">\(\mu\)</span>) de cero y una desviación estándar (<span class="math inline">\(\sigma\)</span>) de uno. Visualmente, esta distribución es una curva simétrica que se asemeja a una campana.</p>
<p><strong>Propiedades</strong>:</p>
<ul>
<li>La curva es simétrica con respecto a su media, que es 0.</li>
</ul></li>
<li><p>La suma del área debajo de la curva es 1, lo que representa una probabilidad total del 100%.</p></li>
<li><p>La distribución indica que aproximadamente el 68% de las observaciones caen dentro de una desviación estándar de la media (entre -1 y 1 en el eje Z), el 95% cae dentro de dos desviaciones estándar y el 99.7% cae dentro de tres.</p></li>
</ul>
</blockquote>
<ol start="2" type="1">
<li>Describe la Ley de los Grandes Números y exprésala matemáticamente.</li>
</ol>
<blockquote class="blockquote">
<p>La <strong>Ley de los Grandes Números</strong> es un principio fundamental en estadística y teoría de probabilidad. Establece que a medida que aumenta el tamaño de una muestra (i.e., la cantidad de observaciones), el valor promedio calculado a partir de esa muestra tiende a acercarse al valor promedio de la población completa. - Matemáticamente, consideremos una secuencia infinita de variables aleatorias, <span class="math inline">\(X_1, X_2, \dots, X_n\)</span>, todas con el mismo valor esperado <span class="math inline">\(E[X_i] = \mu\)</span> y la misma varianza <span class="math inline">\(Var(X_i) = \sigma^2\)</span>. La Ley de los Grandes Números nos dice que el promedio muestral: <span class="math display">\[\bar{X_n} = \frac{1}{n}(X_1 + X_2 + \dots + X_n)\]</span> se acerca al valor esperado <span class="math inline">\(\mu\)</span> a medida que <span class="math inline">\(n\)</span> tiende al infinito.</p>
</blockquote>
<ol start="3" type="1">
<li>Describe el Teoréma del Límite Central y exprésalo matemáticamente.</li>
</ol>
<ul>
<li><div>
<blockquote class="blockquote">
<ul>
<li><p>El <strong>Teorema del Límite Central (TLC)</strong> es otro pilar fundamental en estadística. Declara que si se tiene una muestra suficientemente grande, la distribución de la suma (o promedio) de estas observaciones aleatorias será aproximadamente normal, independientemente de la distribución original de esas variables. Esto justifica el uso generalizado de técnicas estadísticas basadas en la distribución normal en muchas situaciones prácticas.</p></li>
<li><p>Matemáticamente, supongamos que <span class="math inline">\(X_1, X_2, \dots, X_n\)</span> son variables aleatorias independientes e idénticamente distribuidas con media <span class="math inline">\(\mu\)</span> y varianza <span class="math inline">\(\sigma^2\)</span>. El TLC establece que la distribución de la suma (o el promedio) de estas variables se acercará a una distribución normal a medida que el tamaño de la muestra <span class="math inline">\(n\)</span> aumenta. Formalmente: <span class="math display">\[Z_n = \frac{\bar{X_n} - \mu}{\sigma/\sqrt{n}}\]</span> tiene una distribución que converge a una normal estándar <span class="math inline">\(N(0,1)\)</span> cuando <span class="math inline">\(n\)</span> es grande.</p></li>
</ul>
</blockquote>
</div></li>
</ul>
<ol start="4" type="1">
<li>En el contexto de la Ley de los Grandes Números, explica el concepto de convergencia en probabilidad y cómo éste se relaciona con el valor esperado y la varianza de la media muestral.</li>
</ol>
<blockquote class="blockquote">
<p>La Ley de los Grandes Números (LGN) es uno de los pilares fundamentales de la teoría de la probabilidad y tiene importantes implicaciones para la estadística y la inferencia. Para entender su relación con la convergencia en probabilidad y las propiedades de la media muestral, primero debemos desglosar algunos conceptos.</p>
<ul>
<li><strong>Convergencia en Probabilidad</strong>:</li>
</ul>
<p>La idea de convergencia en probabilidad se refiere al comportamiento de una secuencia de variables aleatorias a medida que el número de observaciones se aproxima al infinito. Decimos que una secuencia de variables aleatorias <span class="math inline">\(X_1, X_2, \ldots, X_n\)</span> converge en probabilidad a una variable aleatoria <span class="math inline">\(X\)</span> si, para cualquier valor positivo pequeño <span class="math inline">\(\epsilon\)</span>:</p>
<p><span class="math display">\[\lim_{n \to \infty} P(|X_n - X| &gt; \epsilon) = 0\]</span></p>
<p>En otras palabras, la probabilidad de que la diferencia entre <span class="math inline">\(X_n\)</span> y <span class="math inline">\(X\)</span> sea mayor que <span class="math inline">\(\epsilon\)</span> tiende a cero a medida que <span class="math inline">\(n\)</span> tiende al infinito.</p>
<ul>
<li><strong>Ley de los Grandes Números</strong>: Hay varias versiones de la LGN, pero la más comúnmente discutida es la Ley de los Grandes Números Débil (LLGN). Esta versión establece que si <span class="math inline">\(X_1, X_2, \ldots\)</span> son variables aleatorias independientes e idénticamente distribuidas con esperanza finita <span class="math inline">\(E[X_i] = \mu\)</span> y varianza finita <span class="math inline">\(Var(X_i) = \sigma^2\)</span>, entonces la media muestral:</li>
</ul>
<p><span class="math display">\[\bar{X_n} = \frac{1}{n}(X_1 + X_2 + \ldots + X_n)\]</span></p>
<p>converge en probabilidad al valor esperado <span class="math inline">\(\mu\)</span>:</p>
<p><span class="math display">\[\lim_{n \to \infty} P(|\bar{X_n} - \mu| &gt; \epsilon) = 0\]</span></p>
<p>para cualquier <span class="math inline">\(\epsilon &gt; 0\)</span>.</p>
<ul>
<li><strong>Relación con el Valor Esperado y la Varianza de la Media Muestral</strong>:</li>
</ul>
<p>La Ley de los Grandes Números nos asegura que la media muestral converge en probabilidad al valor esperado de la población. Esta es una propiedad muy poderosa ya que implica que, a medida que aumenta el tamaño de nuestra muestra, nuestra estimación de la media poblacional (a través de la media muestral) se vuelve cada vez más precisa.</p>
<p>En cuanto a la varianza de la media muestral, se puede demostrar que:</p>
<p><span class="math display">\[Var(\bar{X_n}) = \frac{\sigma^2}{n}\]</span></p>
<p>Esto significa que a medida que aumenta el tamaño de la muestra (<span class="math inline">\(n\)</span>), la varianza de la media muestral disminuye. Dicho de otra manera, la dispersión o variabilidad de nuestras medias muestrales alrededor de la media poblacional disminuye a medida que tomamos muestras más grandes. Por lo tanto, nuestras estimaciones se vuelven más consistentes y confiables.</p>
<ul>
<li><strong>Conclusión</strong>: La Ley de los Grandes Números establece un vínculo crucial entre la teoría y la práctica en estadística. Nos dice que, a medida que recolectamos más datos, nuestras estimaciones muestrales se acercan cada vez más a los verdaderos parámetros poblacionales. Esta es la razón por la cual, en la práctica, se valora tener grandes conjuntos de datos, ya que proporcionan estimaciones más precisas y confiables.</li>
</ul>
</blockquote>
<ol start="5" type="1">
<li>¿Cuál es la diferencia matemática entre un estimador y un estimado en estadísticas?</li>
</ol>
<blockquote class="blockquote">
<ul>
<li><p>Un <strong>estimador</strong> es una fórmula o función que proporciona estimaciones de un parámetro poblacional. Es una regla o procedimiento que puede aplicarse a datos de muestra para estimar un parámetro. Dado que las muestras varían, los estimadores son variables aleatorias y, por lo tanto, tienen una distribución de probabilidad. Por ejemplo, la media muestral es un estimador de la media poblacional.</p></li>
<li><p>Un <strong>estimado</strong> es el valor que se obtiene al aplicar un estimador a una muestra particular. Es un valor fijo, mientras que el estimador es una variable aleatoria porque su valor cambia de muestra a muestra.</p></li>
</ul>
</blockquote>
<ol start="6" type="1">
<li>¿Cuál es la definición matemática de la Distribución Muestral y su importancia en inferencia estadística?</li>
</ol>
<blockquote class="blockquote">
<p>Se refiere a cómo se distribuyen todas las posibles valores de un estadístico (como la media muestral o la proporción muestral) cuando se toma repetidamente muestras del mismo tamaño de una población. Es esencial en inferencia estadística porque nos proporciona información sobre cómo varía un estadístico de muestra a muestra. Esta variabilidad nos permite hacer inferencias sobre parámetros poblacionales a partir de datos de muestra.</p>
</blockquote>
<ol start="8" type="1">
<li>Explica en que consiste la estandarización de una variable, describe el proceso matemáticamente e indica cual es su importancia práctica en estadística.</li>
</ol>
<ul>
<li><div>
<blockquote class="blockquote">
<ul>
<li><p>La estandarización es un proceso mediante el cual se transforma una variable para que tenga una media de 0 y una desviación estándar de 1. Se realiza utilizando la fórmula: <span class="math display">\[Z = \frac{X - \mu}{\sigma}\]</span></p></li>
<li><p><strong>Importancia práctica</strong>: La estandarización es útil en estadística y en muchos campos de la ciencia porque permite comparar y combinar datos que originalmente tenían diferentes unidades o escalas. También permite utilizar tablas de la distribución normal estándar y aprovechar las propiedades bien conocidas de esa distribución.</p></li>
</ul>
</blockquote>
</div></li>
</ul>
<ol start="9" type="1">
<li>Explica en qué consiste la varianza de un estimador, cómo se relaciona con el concepto de “error standard”, cómo ésta afecta la precisión de una estimación en una muestra y cómo la varianza de un estimador arbitrario cambia con el tamaño de la muestra.</li>
</ol>
<blockquote class="blockquote">
<ul>
<li><strong>Varianza de un Estimador</strong></li>
</ul>
<p>La varianza de un estimador es una medida que cuantifica cuánto se espera que varíe el estimador en repetidas muestras. En otras palabras, es una medida de la dispersión o la volatilidad de un estimador. Si denotamos nuestro estimador como <span class="math inline">\(\hat{\theta}\)</span>, la varianza de <span class="math inline">\(\hat{\theta}\)</span> se denota generalmente como <span class="math inline">\(\text{Var}(\hat{\theta})\)</span>.</p>
<ul>
<li><p><strong>Relación con el “Error Estándar”</strong>:</p>
<p>El error estándar (EE) es simplemente la raíz cuadrada de la varianza del estimador. Es una medida de la variabilidad o dispersión de un estimador, similar a la desviación estándar en estadísticas descriptivas. Matemáticamente:</p>
<p><span class="math display">\[\text{EE}(\hat{\theta}) = \sqrt{\text{Var}(\hat{\theta})}\]</span></p></li>
</ul>
<p>El error estándar es especialmente útil porque, en el contexto de la inferencia estadística y bajo ciertas condiciones, nos permite hacer declaraciones sobre cuán cerca está nuestro estimador del verdadero parámetro.</p>
<ul>
<li><p><strong>Precisión de la Estimación</strong>:</p>
<p>La precisión de un estimador se refiere a cuán cerca está, en promedio, el estimador del parámetro que intenta estimar. Estimadores con varianzas menores son, en general, más precisos que aquellos con varianzas mayores. Si el error estándar es pequeño, significa que la dispersión de las estimaciones alrededor del verdadero valor del parámetro es pequeña, lo cual es deseable. Sin embargo, es importante notar que un estimador también debe ser insesgado para ser considerado “bueno”.</p></li>
<li><p><strong>Varianza y Tamaño de Muestra</strong>:</p>
<p>Cuando un estimador es consistente entonces a medida que el tamaño de la muestra aumenta, la varianza del estimador tiende a disminuir. Esto tiene sentido intuitivamente: cuanto más datos tengamos, más información tendremos sobre el parámetro que estamos tratando de estimar, lo que reduce la incertidumbre y, por lo tanto, la varianza. Es importante, sin embargo, tener en cuenta que no todo estimador es consistente.</p></li>
</ul>
<p>En resumen, la varianza de un estimador arbitrario nos da una medida de su dispersión, y su raíz cuadrada, el error estándar, nos da una medida de su precisión. Estos conceptos son centrales en inferencia estadística, y una comprensión sólida de ellos es crucial para interpretar resultados y tomar decisiones basadas en datos.</p>
<ul>
<li>La precisión de un estimador aumenta (es decir, su varianza disminuye) a medida que aumenta el tamaño de la muestra.</li>
</ul>
</blockquote>
<ol start="11" type="1">
<li>En una fábrica de galletas, la longitud de las galletas sigue una distribución normal con una media de 7 cm y una desviación estándar de 0.5 cm. Calcula la probabilidad de que una galleta seleccionada al azar tenga una longitud mayor de 7.5 cm.</li>
</ol>
<blockquote class="blockquote">
<p>Dada la información, la longitud de las galletas sigue una distribución normal con una media (<span class="math inline">\(\mu\)</span>) de 7 cm y una desviación estándar (<span class="math inline">\(\sigma\)</span>) de 0.5 cm. Para encontrar la probabilidad de que una galleta seleccionada al azar tenga una longitud mayor de 7.5 cm, debemos calcular <span class="math inline">\(P(X &gt; 7.5)\)</span>.</p>
<p>La técnica general para abordar este tipo de problema es estandarizar la variable (convertirla a una distribución normal estándar) y luego usar una tabla de valores Z o un software para encontrar la probabilidad deseada.</p>
<ul>
<li><strong>Estandarización:</strong> <span class="math display">\[Z = \frac{X - \mu}{\sigma}\]</span> Dónde <span class="math inline">\(X = 7.5\)</span>, <span class="math inline">\(\mu = 7\)</span> y <span class="math inline">\(\sigma = 0.5\)</span>. Sustituimos y obtenemos: <span class="math display">\[Z = \frac{7.5 - 7}{0.5} = 1\]</span></li>
<li><strong>Uso de</strong> <span class="math inline">\(\Phi\)</span>: Para calcular <span class="math inline">\(P(X &gt; 7.5)\)</span> utilizamos: <span class="math display">\[P(X &gt; 7.5) = 1 - \Phi(1)\]</span></li>
</ul>
<p><strong>Conclusión</strong>: Usando una tabla de valores Z o software, <span class="math inline">\(\Phi(1) \approx 0.8413\)</span>. Por lo tanto, <span class="math inline">\(P(X &gt; 7.5) \approx 1 - 0.8413 = 0.1587\)</span>, o 15.87%.</p>
</blockquote>
<ol start="12" type="1">
<li>Supongamos que la altura de los estudiantes de una escuela se distribuye normalmente con una media de 160 cm y una desviación estándar de 10 cm. Si seleccionamos aleatoriamente a un estudiante, ¿cuál es la probabilidad de que su altura esté entre 150 cm y 170 cm?</li>
</ol>
<blockquote class="blockquote">
<ul>
<li><strong>Estandarización:</strong> <span class="math display">\[Z_1 = \frac{150 - \mu}{\sigma}\]</span> <span class="math display">\[Z_2 = \frac{170 - \mu}{\sigma}\]</span> Usando <span class="math inline">\(\mu = 160\)</span> y <span class="math inline">\(\sigma = 10\)</span>: <span class="math display">\[Z_1 = -1\]</span> <span class="math display">\[Z_2 = 1\]</span></li>
<li><strong>Uso de</strong> <span class="math inline">\(\Phi\)</span>: <span class="math display">\[P(150 \leq X \leq 170) = \Phi(1) - \Phi(-1)\]</span></li>
</ul>
<p><strong>Conclusión</strong>: <span class="math inline">\(\Phi(1) \approx 0.8413\)</span> y <span class="math inline">\(\Phi(-1) \approx 0.1587\)</span>. La probabilidad es <span class="math inline">\(0.8413 - 0.1587 = 0.6826\)</span>, o 68.26%.</p>
</blockquote>
<ol start="13" type="1">
<li>En un prueba de SOC114 las notas siguen una distribución normal con una media de 4.5 y una desviación estándar de 1.2. Si se selecciona al azar a un estudiante, ¿cuál es la probabilidad de que obtenga una nota mayor a 6?</li>
</ol>
<blockquote class="blockquote">
<ul>
<li><strong>Estandarización:</strong> <span class="math display">\[Z = \frac{X - \mu}{\sigma}\]</span> Dónde <span class="math inline">\(X = 6\)</span>, <span class="math inline">\(\mu = 4.5\)</span> y <span class="math inline">\(\sigma = 1.2\)</span>: <span class="math display">\[Z = \frac{6 - 4.5}{1.2} \approx 1.25\]</span></li>
<li><strong>Uso de</strong> <span class="math inline">\(\Phi\)</span>: <span class="math display">\[P(X &gt; 6) = 1 - \Phi(1.25)\]</span></li>
</ul>
</blockquote>
<ol start="14" type="1">
<li>En un prueba de SOC114 las notas siguen una distribución normal con una media de 4.5 y una desviación estándar de 1.2. Si se selecciona al azar a un estudiante, ¿cuál es la nota mínima necesario para estar en el 25% superior de los estudiantes?</li>
</ol>
<blockquote class="blockquote">
<ul>
<li><strong>Uso de</strong> <span class="math inline">\(\Phi^{-1}\)</span>: Estamos buscando el valor <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(X &gt; x) = 0.25\)</span> o <span class="math inline">\(P(X \leq x) = 0.75\)</span>. Usando la función inversa: <span class="math display">\[x = \mu + \sigma \times z = \mu + \sigma \times \Phi^{-1}(0.75)\]</span> Sustituyendo <span class="math inline">\(\mu = 4.5\)</span> y <span class="math inline">\(\sigma = 1.2\)</span>: <span class="math display">\[x = 4.5 + 1.2 \times \Phi^{-1}(0.75)\]</span></li>
</ul>
</blockquote>
<ol start="15" type="1">
<li>El peso de los paquetes de harina producidos en una fábrica sigue una distribución normal con una media de 2.5 kg y una desviación estándar de 0.1 kg. Si se toma una muestra aleatoria de 25 paquetes, ¿cuál es la probabilidad de que la media del peso de la muestra sea inferior a 2.48 kg?</li>
</ol>
<blockquote class="blockquote">
<ul>
<li><p><strong>Cálculo del error estándar:</strong> <span class="math display">\[\sigma_{\bar{X}} = \frac{\sigma}{\sqrt{n}}\]</span> Con <span class="math inline">\(\sigma = 0.1\)</span> y <span class="math inline">\(n = 25\)</span>: <span class="math display">\[\sigma_{\bar{X}} = \frac{0.1}{5} = 0.02\]</span></p></li>
<li><p><strong>Estandarización:</strong> <span class="math display">\[Z = \frac{\bar{X} - \mu}{\sigma_{\bar{X}}}\]</span> Con <span class="math inline">\(\bar{X} = 2.48\)</span> y (</p>
<p>= 2.5$: <span class="math display">\[Z = \frac{2.48 - 2.5}{0.02} = -1\]</span></p></li>
<li><p><strong>Uso de</strong> <span class="math inline">\(\Phi\)</span>: <span class="math display">\[P(\bar{X} &lt; 2.48) = \Phi(-1)\]</span></p></li>
</ul>
<p><strong>Conclusión</strong>: <span class="math inline">\(\Phi(-1) \approx 0.1587\)</span>, o 15.87%.</p>
</blockquote>
<ol start="16" type="1">
<li>En un prueba de SOC114 las notas siguen una distribución normal con una media de 4.5 y una desviación estándar de 1.2. Si se selecciona al azar a un estudiante, ¿cuáles el rango de notas necesario para estar por encima del 5% inferior de notas y por debajo del 5% superior?</li>
</ol>
<blockquote class="blockquote">
<ul>
<li><strong>Uso de</strong> <span class="math inline">\(\Phi^{-1}\)</span>: <span class="math display">\[x_1 = \mu + \sigma \times \Phi^{-1}(0.05)\]</span> <span class="math display">\[x_2 = \mu + \sigma \times \Phi^{-1}(0.95)\]</span> Sustituimos <span class="math inline">\(\mu = 4.5\)</span> y <span class="math inline">\(\sigma = 1.2\)</span>: <span class="math display">\[x_1 = 4.5 + 1.2 \times \Phi^{-1}(0.05)\]</span> <span class="math display">\[x_2 = 4.5 + 1.2 \times \Phi^{-1}(0.95)\]</span></li>
</ul>
<p><strong>Conclusión</strong>: Usando tablas o software, <span class="math inline">\(\Phi^{-1}(0.05) \approx -1.645\)</span> y <span class="math inline">\(\Phi^{-1}(0.95) \approx 1.645\)</span>. Por lo tanto, <span class="math inline">\(x_1 \approx 4.5 - 1.2(1.645)\)</span> y <span class="math inline">\(x_2 \approx 4.5 + 1.2(1.645)\)</span>.</p>
</blockquote>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>